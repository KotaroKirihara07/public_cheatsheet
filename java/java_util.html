<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width">
    <title> Cheatsheet </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!-- <link rel = "stylesheet" href ="css/style.css"> -->
    <link href="../css/blog.css" rel="stylesheet">
</head>

<main>
  <!-- ヘッダー --> 
  <div class="container">
    <header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
      <a class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
        <span class="fs-4"> Cheatsheet </span>
      </a>

      <ul class="nav nav-pills">
        <li class="nav-item"><a href="../index.html" class="nav-link active" aria-current="page"> Home </a></li>
        
      </ul>
    </header>
  </div>

  <div class="container">
  <body>
    <div class="row g-5">
      <div class="col-md-12">
        <h3 class="pb-4 mb-4 fst-italic border-bottom">
          <a href="java_index.html"> Java </a>  
        </h3>

        <article class="blog-post">
          <h2 class="blog-post-title"> java.util </h2>
          <p class="blog-post-meta"> 2025/06/21 </p>
          <p> <a href="#Arrays"> Arraysクラス</a>、<a href="#Optional"> Optionalクラス</a>、<a href="#Random">Randomクラス</a>、<a href="#Scanner">Scannerクラス</a> </p>
          <p> streamパッケージ ： <a href="#Stream"> Streamクラス </a>、<a href="#Collectors">Collectorsクラス</a> </p>
          <p> regexパッケージ ： <a href="#Pattern"> Patternクラス </a></p>
          <p> Collectionインターフェイス ： <a href="#Collections"> Collectionsクラス </a>、<a href="#Arraylist">Arraylistクラス</a>、<a href="#LinkedList">LinkedListクラス</a>、<a href="#HashSet">HashSetクラス</a>、<a href="#TreeSet">TreeSetクラス</a>、<a href="#HashMap">HashMapクラス</a>、<a href="#TreeMap">TreeMapクラス</a>、<a href="#ArrayDeque">ArrayDequeクラス</a></p>
          <p> functionパッケージ ： <a href="#Consumer">Consumerインターフェイス</a></p>
          <hr>
        
          <!-- コンテンツ -->
          <h2 id="Arrays"> Arraysクラス </h2>
          <p> 配列を操作するためのクラス。 </p>

          <p> #import宣言 <p> 
          <code> import java.util.Arrays; </code> <br>

          <br>
          <p> #リストの生成 </p>
          <code> var list = Array.asList(1,2,3,4,5); </code> <br>

          <br>
          <p> #配列をリストに変換する </p>
          <code> var list = Arrays.asList(data) </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> Arrays.equals(array1,array2) </code> </td>
                <td> 配列が等しいか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> Arrays.deepEquals(array1,array2) </code> </td>
                <td> 入れ子配列が等しいか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> Arrays.sort(array1) </code> </td>
                <td> ソート </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> Arrays.binarySearch(array1,"abc")</code> </td>
                <td> 値(abc)を検索してそのインデックスを返す </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> Arrays.copyOf(array1)</code> </td>
                <td> 配列のコピー (全コピー) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> Arrays.copyOf(array1,2)</code> </td>
                <td> 配列のコピー (前から2つだけコピー) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> Arrays.toString(array1) </code> </td>
                <td> 配列を文字列化 </td>
                <td> String </td>
              </tr>
              <tr>
                <td> <code> Arrays.copyOfRange(array1,2,4) </code> </td>
                <td> 特定の範囲だけコピー (2から3まで) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> Arrays.fill(array1,4,6,"A") </code> </td>
                <td> 内容の置換 (4から5まで"A"に変換する) </td>
                <td> void </td>
              </tr>
            </tbody>
          </table>
          <hr>

          <h2 id="Optional"> Optionalクラス </h2>
          <p> null安全のためのクラス。</p>

          <p> #import宣言 </p>
          <code> import java.util.Optional; </code> <br>

          <br>
          <p> #空のOptionalを生成する </p>
          <code> var opt1 = Optional.empty(); </code> <br>

          <br>
          <p> #メソッド集 </p> 
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> Optional.empty() </code> </td>
                <td> 空のOptionalを生成する </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> Optional.of(val) </code> </td>
                <td> 指定された値からOptionalを生成する (nullの場合は例外) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> Optional.ofNullable(val) </code> </td>
                <td> 指定された値からOptionalを生成する (nullの場合は空のOptional) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> opt1.isPresent() </code> </td>
                <td> Optionalが非null値をもっているか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> opt1.ifPresent(処理) </code> </td>
                <td> Optionalが非null値を持っている場合、処理を実行する </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> opt1.orElse(val2) </code> </td>
                <td> Optionalが非null値を持っている場合はその値を、さもなければval2を返す</td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> opt1.orElseGet(ラムダ式) </code> </td>
                <td> Optionalが非null値を持っている場合はその値を、さもなければラムダ式の戻り値を返す </td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
          <hr>

          
          <h2 id="Random"> Randomクラス </h2>
          <p> 乱数を扱うためのクラス。 </p>

          <p> #import宣言 </p>
          <code> import java.util.Random; </code> <br>

          <br>
          <p> #インスタンス化</p>
          <code> Random rnd = new Random(); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>  rnd.nextBoolean() </code> </td>
                <td> ブール値で乱数を取得する </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> rnd.nextFloat() </code> </td>
                <td> float値(0.0~1.0)で乱数を生成 </td>
                <td> float </td>
              </tr>
              <tr>
                <td> <code> rnd.nextDouble() </code> </td>
                <td> double値(0.0~1.0)で乱数を生成 </td>
                <td> double </td>
              </tr>
              <tr>
                <td> <code> rnd.nextInt(x) </code> </td>
                <td> int値(0~x)で乱数を生成 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> rnd.nextLong() </code> </td>
                <td> long値で乱数を生成 </td>
                <td> long </td>
              </tr>
            </tbody>
          </table>
          <hr>    


          <h2 id="Scanner"> Scannerクラス </h2>
          <p> 標準入出力を扱うためのクラス。 </p>

          <p> #import宣言 </p>
          <code> import java.util.Scanner; </code> <br>

          <br>
          <p> #インスタンス化 </p>
          <code> Scanner scan = new Scanner(System.in); </code> <br>

          <br>
          <p> #String型の変数を入力する (改行も入力される) </p>
          <code> Sting str = scan.nextLine(); </code> <br>

          <br>
          <p> #String型の変数を入力する (推奨) </p>
          <code> Sting str = scan.next(); </code> <br>

          <br>
          <p> #int型の変数を入力する </p>
          <code> int num1 = scan.nextInt(); </code> <br>

          <br>
          <p> #long型の変数を入力する </p>
          <code> long num2 = scan.nextLong(); </code> <br>

          <br>
          <p> #Double型の変数を入力する </p>
          <code> double num3 = scan.nextDouble(); </code> <br>
          <hr> 

          <h2 id="Stream"> Streamクラス </h2>
          <p> 配列やコレクションを加工するためのクラス。 </p>

          <p> #import宣言 </p>
          <code> import java.util.stream.Stream; </code> <br>

          <br>
          <p> #Collection(list)からストリームを生成する </p>
          <code> list.stream(); </code> <br>

          <br>
          <p>#ファクトリーメソッド集 (ストリームの生成)</p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>var stream = Stream.of("a","b","c")</code> </td>
                <td> 可変長引数をストリームに変換する </td>
              </tr>
              <tr>
                <td> <code> var stream = Stream.generate(() ->  { 処理 })</code> </td>
                <td> <code>return</code>で返した処理内容をストリームにする(長さは無限) </td>
              </tr>
              <tr>
                <td> <code>var stream = Stream.iterate(i,(num) -> { 処理 })</code> </td>
                <td> <code>i</code>を初期値とし、<code>return</code>で返した処理内容をストリームにする(長さは無限) </td>
              </tr>
              <tr>
                <td> <code>var stream = Stream.builder().add(1).add(2).add(3).build()</code> </td>
                <td> Stream.builderからストリームの生成 </td>
              </tr>
              <tr>
                <td> <code>var stream = Stream.concat(stream1,stream2)</code> </td>
                <td> 複数のストリームを結合する </td>
              </tr>
            </tbody>
          </table>

          <br>
          <p> #中間処理 (ストリームの加工) </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>stream.filter(s -> s.startsWith("https://"))</code> </td>
                <td> 前方一致するものだけ取り出す </td>
              </tr>
              <tr>
                <td> <code>stream.map(s -> s.length())</code> </td>
                <td> それぞれの要素の文字数を返す</td>
              </tr>
              <tr>
                <td> <code>stream.sorted(Comparator.natualOrder()) </code> </td>
                <td> 自然順序でソートする </td>
              </tr>
              <tr>
                <td> <code>stream.sorted(Comparator.reverseOrder())</code> </td>
                <td> 自然順序の逆順でソートする</td>
              </tr>
              <tr>
                <td> <code>stream.skip(n)</code> </td>
                <td> n番目までの要素を切り捨てる </td>
              </tr>
              <tr>
                <td> <code>stream.limit(n)</code> </td>
                <td> n+1番目以降の要素を切り捨てる </td>
              </tr>
              <tr>
                <td> <code> stream.dropWhile(i -> i&lt;0)</code> </td>
                <td> 先頭から条件を満たす間の値を除去する </td>
              </tr>
              <tr>
                <td> <code>stream.takeWhile(i -> i&lt;0)</code> </td>
                <td> 先頭から条件を満たす間の値だけを取り出す </td>
              </tr>
              <tr>
                <td> <code>stream.peek(System.out::println)</code> </td>
                <td> 途中の状態を出力する </td>
              </tr>
              <tr>
                <td> <code> stream.distinct() </code> </td>
                <td> 値の重複を除去する </td>
              </tr>
            </tbody>
          </table>

          <br>
          <p> #終端処理 (ストリームの出力) </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>stream.forEach(v -> System.out.println(v))</code> </td>
                <td> 要素を出力する </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.findfirst().orElse("Empty") </code> </td>
                <td> 最初の要素を取り出す(存在しなければ"Empty"を返す)</td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> stream.anyMatch(v -> v&lt;0)</code> </td>
                <td> 少なくとも1つの要素が条件を満たす </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> stream.allMatch(v -> v&lt;0)</code> </td>
                <td> すべての要素が条件を満たす </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> stream.noneMatch(v -> v&lt;0)</code> </td>
                <td> すべての要素が条件を満たさない </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> stream.toArray()</code> </td>
                <td> 配列に変換する </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.count() </code> </td>
                <td> 要素の個数 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> stream.sum() </code> </td>
                <td> 合計値 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.average().orElse(0)</code> </td>
                <td> 平均値 </td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
          <hr>

          <h2 id="Collectors"> Collectorsクラス</h2>
          <p> ストリームをコレクションに変換するためのクラス。</p>

          <p> #import宣言 </p>
          <code> import java.util.stream.Collectors; </code> <br>

          <br>
          <p> #変換メソッド集</p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>stream.collect(Collectors.toList)</code> </td>
                <td> リストへの変換 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.toSet)</code> </td>
                <td> セットへの変換 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.toMap(keys,values))</code> </td>
                <td> マップへの変換 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.toCollection)</code> </td>
                <td> 一般的なコレクションへの変換</td>
                <td> var </td>
              </tr>
            </tbody>
          </table>

          <p> #リダクション処理メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code>stream.collect(Collectors.joining(",","[","]"))</code> </td>
                <td> 文字列リストをカンマ区切りで連結して前に「 [ 」、後ろに「 ] 」をつける</td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.groupingBy(str -> str.length()))</code> </td>
                <td> 文字数でグループ化する。「キー=リスト」のマップ形式で返す。</td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.partitioningBy(str -> str.length > 3))</code> </td>
                <td> 条件で2つにグループ化する。{false=[],true=[]}のマップ形式で返す。</td>
              </tr>
              <tr>
                <td> <code>stream.collect(Collectors.collectingthen(---))</code> </td>
                <td> </td>
              </tr>
            </tbody>
          </table>
          <hr>

          <h2 id="Pattern"> Patternクラス </h2>
          <p> 正規表現を扱うためのクラス。 </p> 

          <p> #import宣言</p>
          <code> import java.util.regex.Pattern; </code> <br>

          <br>
          <p> #取り出す文字列を定義する </p>
          <code> var rx = "正規表現パターン"; </code> <br>

          <br>
          <p> #正規表現パターン </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> パターン </th>
                <th scope="col"> 説明 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> XYZ </code> </td>
                <td> 「XYZ」という文字列 </td>
              </tr>
              <tr>
                <td> <code> [XYZ] </code> </td>
                <td> X,Y,Zのいずれかの1文字 </td>
              </tr>
              <tr>
                <td> <code> [^XYZ]</code> </td>
                <td> X,Y,Z以外のいずれかの1文字</td>
              </tr>
              <tr>
                <td> <code> [X-Z] </code> </td>
                <td> X~Zの範囲の中の1文字 </td>
              </tr>
              <tr>
                <td> <code> [X|Y|Z] </code> </td>
                <td> X,Y,Zのいずれか </td>
              </tr>
              <tr>
                <td> <code> X*</code> </td>
                <td> 0文字以上のX </td>
              </tr>
              <tr>
                <td> <code> X? </code> </td>
                <td> 0文字または1文字のX </td>
              </tr>
              <tr>
                <td> <code> X+ </code> </td>
                <td> 1文字以上のX </td>
              </tr>
              <tr>
                <td> <code> X{n} </code> </td>
                <td> Xとn回一致 </td>
              </tr>
              <tr>
                <td> <code> X{n,}</code> </td>
                <td> Xとn回以上一致 </td>
              </tr>
              <tr>
                <td> <code> X{m,n} </code> </td>
                <td> Xとm~n回一致 </td>
              </tr>
              <tr>
                <td> <code> ^ </code> </td>
                <td> 行の先頭に一致 </td>
              </tr>
              <tr>
                <td> <code> $ </code> </td>
                <td> 行の末尾に一致 </td>
              </tr>
              <tr>
                <td> <code> . </code> </td>
                <td> 任意の1文字 </td>
              </tr>
              <tr>
                <td> <code> \w </code> </td>
                <td> 大文字小文字の英字、数字、アンダースコアに一致</td>
              </tr>
              <tr>
                <td> <code> \W </code> </td>
                <td> 文字以外に一致 </td>
              </tr>
              <tr>
                <td> <code> \d </code> </td>
                <td> 数字に一致 </td>
              </tr>
              <tr>
                <td> <code> \D </code> </td>
                <td> 数字以外に一致 </td>
              </tr>
              <tr>
                <td> <code> \n </code> </td>
                <td> 改行に一致 </td>
              </tr>
              <tr>
                <td> <code> \r </code> </td>
                <td> 復帰に一致 </td>
              </tr>
              <tr>
                <td> <code> \t </code> </td>
                <td> タブ文字に一致 </td>
              </tr>
              <tr>
                <td> <code> \s </code> </td>
                <td> 空白文字に一致 </td>
              </tr>
              <tr>
                <td> <code> \S </code> </td>
                <td>空白以外の文字 </td>
              </tr>
              <tr>
                <td> <code> \~ </code> </td>
                <td> 「~」で表される文字 </td>
              </tr>
              <tr>
                <td> <code> "A(?=B)" </code> </td>
                <td> Aの直後にBが続く場合にだけマッチ</td>
              </tr>
              <tr>
                <td> <code> "A(?!B)" </code> </td>
                <td> Aの直後にBが続かない場合にだけマッチ</td>
              </tr>
              <tr>
                <td> <code> "(?&lt;=B)A" </code> </td>
                <td> Aの直前にBがある場合にだけマッチ </td>
              </tr>
              <tr>
                <td> <code> "(?&lt;!B)A" </code> </td>
                <td> Aの直前にBがない場合にだけマッチ </td>
              </tr>
            </tbody>
          </table>

          <br>
          <p> #Patternオブジェクトを作成する </p>
          <code> var ptn = Pattern.compile(rx,検索オプション); </code> <br>

          <br>
          <p> #メソッド集 (Patternオブジェクト)</p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> ptn.matcher(str) </code> </td>
                <td> Matcherオブジェクトを作成する </td>
                <td> Matcher </td>
              </tr>
              <tr>
                <td> <code> ptn.split(str) </code> </td>
                <td> 文字列を分割する </td>
                <td> String[] </td>
              </tr>
            </tbody>
          </table>

          <br>
          <p> #クラスメソッド集 (Patternクラス)</p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> Pattern.matches(rx, str) </code> </td>
                <td> strが正規表現と一致しているか </td>
                <td> boolean </td>
              </tr>
            </tbody>
          </table>

          <br>
          <p> #メソッド集 (Matcherオブジェクト)</p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> match.start() </code> </td>
                <td> マッチング開始位置 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> match.end() </code> </td>
                <td> マッチング終了位置 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> match.group() </code> </td>
                <td> マッチング文字列 </td>
                <td> String </td>
              </tr>
              <tr>
                <td> <code> match.group(n) </code> </td>
                <td> マッチング文字列のn番目のブロックを取得 </td>
                <td> String </td>
              </tr>
            </tbody>
          </table>

          <p> #検索オプション </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> 設定値 </th>
                <th scope="col"> 説明 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> Pattern.CASE_INSENSITIVE</code> </td>
                <td> 大文字小文字を区別しない </td>
              </tr>
              <tr>
                <td> <code> Pattern.MULTILINE </code> </td>
                <td> 複数行モードの有効化 </td>
              </tr>
              <tr>
                <td> <code> Pattern.DOTALL </code> </td>
                <td> 「.」が行末記号を含む任意の文字にマッチ </td>
              </tr>
              <tr>
                <td> <code> Pattern.UNICODE_CASE </code> </td>
                <td> Unicodeに準拠した大文字と小文字を区別しないマッチングを有効化 </td>
              </tr>
              <tr>
                <td> <code> Pattern.UNIX_LINES </code> </td>
                <td> 「\n」だけを行末記号として扱う </td>
              </tr>
              <tr>
                <td> <code> Pattern.LITERAL </code> </td>
                <td> パターンをリテラル文字として解析 (「\d」などの意味を無効化)</td>
              </tr>
              <tr>
                <td> <code> Pattern.COMMENTS</code> </td>
                <td> 空白とコメントの有効化 </td>
              </tr>
            </tbody>
          </table>
          <hr>

          <h2 id="Collections"> Collectionsクラス </h2>
          <p> コレクションを扱うためのクラス。 </p>
          <p> #メソッド集 </p> 
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> Collections.addAll(list1,list2) </code> </td>
                <td> list1にlist2の内容をコピーする </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableCollection(data) </code> </td>
                <td> 変更不能なCollectionを生成する </td>
                <td> Collection </td> 
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableList(data) </code> </td>
                <td> 変更不能なListを生成する </td>
                <td> List </td> 
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableSet(data) </code> </td>
                <td> 変更不能なSetを生成する </td>
                <td> Set </td> 
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableSortedSet(data) </code> </td>
                <td> 変更不能なSortedSetを生成する </td>
                <td> Set </td> 
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableMap(data) </code> </td>
                <td> 変更不能なMapを生成する </td>
                <td> Map </td> 
              </tr>
              <tr>
                <td> <code> Collections.unmodifiableSortedMap(data) </code> </td>
                <td> 変更不能なSortedMapを生成する </td>
                <td> Map </td> 
              </tr>
            </tbody>
          </table>
          <hr>

          <h2 id="Arraylist"> Arraylistクラス </h2>
          <p> 可変長配列を扱うためのクラス。配列とは異なり後からサイズの変更を行うことが可能である。
              インデックス値による要素の読み書き性能については優れているが、要素の頻繁な挿入/削除は苦手。
              リストのサイズをあらかじめ規定しておくことも可能。デフォルト値は10。 
              参照型はラッパークラスで定義する。
          </p>

          <p> #import宣言 </p>
          <code> import java.util.ArrayList; </code> <br>

          <br>
          <p> #リストの生成 その1 </p>
          <code> List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); </code> <br>

          <br>
          <p> #リストの生成 その2 </p>
          <code> var list = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4,5)); </code> <br>

          <br>
          <p> #リストの生成 その3 </p>
          <code>var list = new ArrayList&lt;Integer&gt;() { </code> <br>
          <code>&nbsp;&nbsp;&nbsp;&nbsp;{ </code> <br>
          <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(1); </code> <br>
          <code>&nbsp;&nbsp;&nbsp;&nbsp;} </code> <br>
          <code>}; </code> <br>
          
          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> list.get(n) </code> </td>
                <td> n番目のindexの値を取得する</td>
                <td> var</td>
              </tr>
              <tr>
                <td> <code> list.size() </code> </td>
                <td> リストの要素数 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> list.add(n, value) </code> </td>
                <td> n番目のindexにvalueを追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.add(value) </code> </td>
                <td> 末尾にvalueを追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.addAll(list2) </code> </td>
                <td> 末尾にリストを追加 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.addAll(n, list2) </code> </td>
                <td> n番目のindexにリストを追加 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.set(n, value) </code> </td>
                <td> n番目のindexにvalueを設定 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> list.remove(n) </code> </td>
                <td> n番目のindexを削除 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.removeAll(list2) </code> </td>
                <td> list2のすべての要素を削除 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.removeRange(n, m+1) </code> </td>
                <td> n番目からm番目までの要素を削除 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.retainALL(list2) </code> </td>
                <td> list2に含まれていない要素を削除 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.clear() </code> </td>
                <td> すべての要素を削除 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.contains(value) </code> </td>
                <td> 指定の要素を含むか</td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.indexOf(value) </code> </td>
                <td> 指定の要素の位置を前から検索 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> list.lastIndexOf(value) </code> </td>
                <td> 指定の要素の位置を後ろから検索 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> list.isEmpty() </code> </td>
                <td> リストが空かどうか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> list.clone() </code> </td>
                <td> すべての要素をコピー </td>
                <td> リスト </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="LinkedList"> LinkedListクラス </h2>
          <p> 二重リンクリストを扱うためのクラス。
              要素の挿入/削除については優れているが、インデックス値による要素の読み書きは苦手。
              参照型はラッパークラスで定義する。
          </p>

          <p> #import宣言 </p>
          <code> import java.util.LinkedList;</code> <br>

          <br>
          <p> #リストの生成 その1 </p>
          <code> List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); </code> <br>

          <br>
          <p> #リストの生成 その2 </p>
          <code> var list = new LinkedList&lt;Integer&gt;(Arrays.asList(1,2,3,4,5)); </code> <br>

          <br>
          <p> #メソッド集 (ArrayListクラスのメソッドも使用可能) </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> list.getFirst() </code> </td>
                <td> 先頭の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> list.getLast() </code> </td>
                <td> 末尾の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> list.addFirst(1) </code> </td>
                <td> リストの先頭に要素を追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.addLast(1) </code> </td>
                <td> リストの末尾に要素を追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> list.removeFirst()</code> </td>
                <td> 先頭の要素を削除 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> list.removeLast() </code> </td>
                <td> 末尾の要素を削除 </td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="HashSet"> HashSetクラス </h2>
          <p> 並び順を管理しない集合を扱うためのクラス。参照型はラッパークラスで定義する。 </p>

          <p> #import宣言 </p>
          <code> import java.util.HashSet;</code> <br>

          <br>
          <p> #セットの生成 その1 </p>
          <code> Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;(); </code> <br>


          <br>
          <p> #セットの生成 その2 </p>
          <code> var hs = new HashSet&lt;Integer&gt;(Array.asList(1,2,3,4,5)); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> hs.size()</code></td>
                <td> 要素数を取得 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> hs.add(x) </code></td>
                <td> 要素を追加 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.remove(x) </code></td>
                <td> 要素を削除 </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.clear() </code></td>
                <td> すべての要素を削除 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> hs.contains(x) </code></td>
                <td> xを含むか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.containsAll(hs2)</code></td>
                <td> hs2がhsの部分集合か </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.clone() </code></td>
                <td> すべての要素をコピー </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> hs.isEmpty() </code></td>
                <td> 要素が空か </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.addAll(hs2) </code></td>
                <td> hsを(hsとhs2の和集合)に変換する </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.removeAll(hs2) </code></td>
                <td> hsを(hsとhs2の差集合)に変換する </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> hs.retainAll(hs2) </code></td>
                <td> hsを(hsとhs2の積集合)に変換する </td>
                <td> boolean </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="TreeSet"> TreeSetクラス </h2>
          <p> 要素が自動的にソートされる集合。HashSetクラスで利用できるメソッドも使用できる。
              参照型はラッパークラスで定義する。
          </p>

          <p> #import宣言 </p>
          <code> import java.util.TreeSet;</code> <br>

          <br>
          <p> #セットの生成 その1 </p>
          <code> Set&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); </code> <br>

          <br>
          <p> #セットの生成 その2 </p>
          <code> var ts = new TreeSet&lt;Integer&gt;(Array.asList(1,2,3,4,5)); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> ts.ceiling(n) </code></td>
                <td> n以上の要素の中で最小のものを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.higher(n) </code></td>
                <td> nより大きい要素の中で最小のものを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.floor(n) </code></td>
                <td> n以下の要素の中で最大のものを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.lower(n) </code></td>
                <td> nより小さい要素の中で最大のものを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.first() </code></td>
                <td> 最初の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.last() </code></td>
                <td> 最後の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.headSet(n) </code></td>
                <td> nより小さい要素の集合を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.headSet(n,true) </code></td>
                <td> n以下の要素の集合を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.subSet(n,m) </code></td>
                <td> n以上mより小さい要素の集合を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.tailSet(n) </code></td>
                <td> n以上の要素の集合を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.tailSet(n,false) </code></td>
                <td> nより大きい要素の集合を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> ts.descendingSet() </code></td>
                <td> 要素を逆順に並び替える </td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="HashMap"> HashMapクラス </h2>
          <p> キーの順序が保証されないマップを扱うためのクラス。参照型はラッパークラスで定義する。 </p>

          <p> #import宣言 </p>
          <code> import java.util.Map; </code> <br>
          <code> import java.util.HashMap; </code> <br>

          <br>
          <p> #マップの生成 その1 </p>
          <code> Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); </code> <br>


          <br>
          <p> #マップの生成 その2 </p>
          <code> var map = new HashMap&lt;String, Integer&gt;(Map.of("a",1,"b",2,"c",3)); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> map.get(key) </code> </td>
                <td> 指定のキーの値を取得する </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.getOrDefault(key,default) </code> </td>
                <td> 指定のキーの値を取得する(存在しない場合、defaultを返す) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.entrySet() </code> </td>
                <td> すべての要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.KeySet() </code> </td>
                <td> すべてのキーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.size() </code> </td>
                <td> マップの要素数を取得 </td>
                <td> int </td>
              </tr>
              <tr>
                <td> <code> map.values() </code> </td>
                <td> すべての値を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.put(key,value) </code> </td>
                <td> 指定のキーと値の要素を追加 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.putIfAbsent(key,value) </code> </td>
                <td> 指定のキーがなければ要素を追加 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.clear() </code> </td>
                <td> すべての要素を削除 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> map.remove(key) </code> </td>
                <td> 指定のキーの要素を削除する </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> map.containsKey(key) </code> </td>
                <td> 指定のキーが含まれているか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> map.containsValue(value) </code> </td>
                <td> 指定の値が含まれているか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> map.isEmpty() </code> </td>
                <td> マップの中身が空かどうか </td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> map.clone() </code> </td>
                <td> すべての要素をコピー </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.replace(key,value) </code> </td>
                <td> 指定のキーの値を変換 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.replace(key,old_value,new_value) </code> </td>
                <td> 指定のキーの値を変換 (old_valueをnew_valueに変換) </td>
                <td> boolean </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="TreeMap"> TreeMapクラス </h2>
          <p> ソート済みマップを扱うためのクラス。参照型はラッパークラスで定義する。 </p>

          <p> #import宣言 </p>
          <code> import java.util.Map; </code> <br>
          <code> import java.util.TreeMap; </code> <br>

          <br>
          <p> #マップの生成 その1 </p>
          <code> Map&lt;String, Integer&gt; map = new TreeMap&lt;String, Integer&gt;(); </code> <br>

          <br>
          <p> #マップの生成 その2 </p>
          <code> var map = new TreeMap&lt;String, Integer&gt;(Map.of("a",1,"b",2,"c",3)); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> map.ceilingEntry(key) </code> </code> </td>
                <td> 指定のキーと等しいか大きいキーで最小のキーで最小のエントリーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.floorEntry(key) </code> </code> </td>
                <td> 指定のキーと等しいか小さい最小のキーで最大のエントリーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.higherEntry(key) </code> </code> </td>
                <td> 指定のキーより大きいキーで最小のエントリーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.lowerEntry(key) </code> </code> </td>
                <td> 指定のキーより小さいキーで最大のエントリーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.ceilingKey(key) </code> </code> </td>
                <td> 指定のキーと等しいか大きいキーで最小のキーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.floorKey(key) </code> </code> </td>
                <td> 指定のキーと等しいか小さいキーで最大のキーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.higherKey(key) </code> </code> </td>
                <td> 指定のキーより大きいキーで最小のキーを取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> map.lowerKey(key) </code> </code> </td>
                <td> 指定のキーより小さいキーで最大のキーを取得 </td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
          <hr> 

          <h2 id="ArrayDeque"> ArrayDequeクラス </h2>
          <p> 循環配列を扱うためのクラス。スタックやキューの実装に使用する。参照型はラッパークラスで定義する。</p>

          <p> #import宣言 </p> 
          <code> import java.util.ArrayDeque; </code> <br>

          <br>
          <p> #キューの生成 </p> 
          <code> var data = ArrayDeque&lt;Integer&gt;(Array.asList(1,2,3,4,5)); </code> <br>

          <br>
          <p> #メソッド集 </p>
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col"> メソッド </th>
                <th scope="col"> 説明 </th>
                <th scope="col"> 戻り値の型 </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td> <code> data.addFirst(1) </code> </td>
                <td> 先頭に要素を追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> data.addLast(1) </code> </td>
                <td> 末尾に要素を追加 </td>
                <td> void </td>
              </tr>
              <tr>
                <td> <code> data.offerFirst(1) </code> </td>
                <td> 先頭に要素を追加 (失敗時false)</td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> data.offerLast(1) </code> </td>
                <td> 末尾に要素を追加 (失敗時false)</td>
                <td> boolean </td>
              </tr>
              <tr>
                <td> <code> data.removeFirst() </code> </td>
                <td> 先頭の変数を取り出した後削除 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.removeLast() </code> </td>
                <td> 末尾の変数を取り出した後削除 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.pollFirst() </code> </td>
                <td> 先頭の変数を取り出した後削除 (失敗時はnull)</td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.pollLast() </code> </td>
                <td> 末尾の変数を取り出した後削除 (失敗時はnull)</td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.getFirst() </code> </td>
                <td> 先頭の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.getLast() </code> </td>
                <td> 末尾の要素を取得 </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.peekFirst() </code> </td>
                <td> 先頭の要素を取得 (失敗時はnull) </td>
                <td> var </td>
              </tr>
              <tr>
                <td> <code> data.peekLast() </code> </td>
                <td> 末尾の要素を取得 (失敗時はnull)</td>
                <td> var </td>
              </tr>
            </tbody>
          </table>
        <hr> 

        <h2 id="Consumer"> Consumerインターフェイス </h2>
        <p> 説明 </p>

        <p> #import宣言 </p> 
        <code> import java.util.function.Consumer; </code> <br>

        <br>
        <p> #ラムダ式</p>
        <code> (引数の型 仮引数) -> {メソッド} </code> <br>

        <br>
        <p> #メソッド集 </p>
        <table class="table table-striped">
          <thead>
            <tr>
              <th scope="col"> メソッド </th>
              <th scope="col"> 説明 </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td> <code></code> </td>
              <td> </td>
            </tr>
          </tbody>
        </table>
        <hr>
        </article>
      </div>
    </div>

    <footer class="text-muted py-5">
      <div class="container">
        <hr>
        <p class="mb-1"> フッターコメント </p>
      </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

  </body>
  </div>
</main>
</html>